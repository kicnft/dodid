<!DOCTYPE html>
<html lang="ja" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8" />
<title>DoDiD!</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=1">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.8/themes/default/style.min.css" />
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery-toast-plugin/1.3.2/jquery.toast.min.css" integrity="sha512-wJgJNTBBkLit7ymC6vvzM1EcSWeM9mmOu+1USHaRBbHkm6W9EgM0HY27+UtUaprntaYQJF75rc8gjxllKs5OIQ==" crossorigin="anonymous" />
<style>
canvas {
	width:100%
}
.keyarea {
  resize: none;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.8/jstree.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-toast-plugin/1.3.2/jquery.toast.min.js" integrity="sha512-zlWWyZq71UMApAjih4WkaRpikgY9Bz1oXIW5G0fED4vk14JjGlQ1UmkGM392jEULP8jbNMiwLWdM8Z87Hu88Fw==" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
<script src="https://xembook.github.io/nem2-browserify/symbol-sdk-pack-2.0.4.js"></script>
<script src="https://xembook.github.io/symbol-browserify/metal-on-symbol-0.2.2.js"></script>
<script src="config.js"></script><!-- configSymbolApplication -->
<script src="symapp.js"></script>
</head>
<body>
<div class="container">
	<b><span id="wallet_id"></span> WALLET</b>
	<h1>DoDiD!</h1>
	<b>Multisig Tree</b>
	<button onclick="clickAddMultisig()">è¿½åŠ </button>
	<button onclick="clickDelMultisig()">å‰Šé™¤</button>
	<button onclick="clickUpdMultisigMinValue()">é–¾å€¤å¤‰æ›´</button>
	<div id="multisig_tree"></div><br>
	<b>Address List</b>
	<button onclick="clickAddAddress()">ã‚¢ãƒ‰ãƒ¬ã‚¹è¿½åŠ </button>
	<button onclick="clickAddGroup()">ã‚°ãƒ«ãƒ¼ãƒ—è¿½åŠ </button>
	<button onclick="clickDelGroup()">å‰Šé™¤</button>
	<div id="address_tree"></div><br/>
	<button onclick="clickTransfer()">è»¢é€</button>
	<hr>
	<b>Transaction List</b>
	<div id="transaction_tree"></div>
	<button onclick="clickTransaction()" >ç½²åãƒ»é€šçŸ¥</button>
	<hr>
	<b>Information</b>
	<div id="partial_transaction_tree"></div>
	<hr>
	<b>Address QR</b>
	<div id="signer_address"></div>
	<div id="signer_address_plain"></div>
	<button onclick="clickKey()">éµæƒ…å ±</button>
<hr>
	<footer>KICN-FT</footer>
</div><!-- container -->

<!-- QRã‚¹ã‚­ãƒ£ãƒ³ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div class="modal fade" id="modal_qr_scan" tabindex="-1" role="dialog">
	<div class="modal-dialog" role="document"><div class="modal-content">

		<div class="modal-header">
			<h5 class="modal-title">QRã‚¹ã‚­ãƒ£ãƒ³</h5>
			<button type="button" class="close" data-dismiss="modal" aria-label="é–‰ã˜ã‚‹"><span aria-hidden="true">&times;</span></button>
		</div>

		<div class="modal-body">
			<label></label>
			<div class="input-group">
				<label class="input-group-btn mr-1">
					<span class="btn btn-primary">
						ç”»åƒã§ã‚¹ã‚­ãƒ£ãƒ³<input id="file_image" type="file" style="display:none">
					</span>
				</label>
			</div>
			<canvas id="canvas"  width="100%" hidden></canvas>
			<div id="scan_data" class="text-break"></div>
			<label>ãƒãƒ¼ãƒ ã‚¹ãƒšãƒ¼ã‚¹ã§ç™»éŒ²</label>
			<input type="text" id="modal_qr_scan_namespace">
		</div>

		<div class="modal-footer">
			<button type="button" class="btn btn-default" data-dismiss="modal">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
			<button type="button" class="btn btn-primary" onclick="clickModalQrScan()">OK</button>
		</div><!-- /.modal-footer -->
	</div></div><!-- /.modal-content --><!-- /.modal-dialog -->
</div><!-- /.modal -->

<!-- è»¢é€ãƒ¢ã‚¶ã‚¤ã‚¯è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div class="modal fade" id="modal_transfer" tabindex="-1" role="dialog">
<div class="modal-dialog" role="document"><div class="modal-content">

	<div class="modal-header">
		<h5 class="modal-title">ãƒ¢ã‚¶ã‚¤ã‚¯é¸æŠ</h5>
		<button type="button" class="close" data-dismiss="modal" aria-label="é–‰ã˜ã‚‹"><span aria-hidden="true">&times;</span></button>
	</div>
	<div class="modal-body">
		<label>é¸æŠã—ã¦ãã ã•ã„</label>

		<!-- ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆè¦ç´  -->
		<template id="form_template">
		<div class="form_mosaic">
			<label>ãƒ¢ã‚¶ã‚¤ã‚¯ID:</label>
			<select></select><br>
			<label>æ•°é‡:</label>
			<input type="text">
			<button class="remove-button">å–ã‚Šæ¶ˆã—</button>
		</div>
		</template>
		<button onclick="clickModalAddMosaicForm()">ãƒ¢ã‚¶ã‚¤ã‚¯è¿½åŠ </button>

		<div id="form-container"></div>
		<hr>
		<label>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸:</label>
		<input type="text" id="message">
	</div>
	<div class="modal-footer">
		<button type="button" class="btn btn-primary" onclick="clickModalTransfer()">OK</button>
		<button type="button" class="btn btn-default" data-dismiss="modal">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>

	</div><!-- /.modal-footer -->
</div></div><!-- /.modal-content --><!-- /.modal-dialog -->
</div><!-- /.modal -->


<!-- ãƒãƒ«ãƒã‚·ã‚°é–¾å€¤å¤‰æ›´ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div class="modal fade" id="modal_mod_multisig" tabindex="-1" role="dialog">
<div class="modal-dialog" role="document"><div class="modal-content">

	<div class="modal-header">
		<h5 class="modal-title">ãƒãƒ«ãƒã‚·ã‚°é–¾å€¤å¤‰æ›´</h5>
		<button type="button" class="close" data-dismiss="modal" aria-label="é–‰ã˜ã‚‹"><span aria-hidden="true">&times;</span></button>
	</div>
	<div class="modal-body">
		<label>é¸æŠã—ã¦ãã ã•ã„</label>

		<p>ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«å¿…è¦ãªç½²åæ•°: <span id="valueMinApproval">0</span></p>
		<button id="decreaseMinApproval">æ¸›å°‘</button>
		<button id="increaseMinApproval">å¢—åŠ </button>

		<p>é€£ç½²è€…ã‚’é™¤å¤–ã™ã‚‹ãŸã‚ã«å¿…è¦ãªç½²åæ•°: <span id="valueMinRemoval">0</span></p>
		<button id="decreaseMinRemoval">æ¸›å°‘</button>
		<button id="increaseMinRemoval">å¢—åŠ </button>
	</div>
	<div class="modal-footer">
		<button type="button" class="btn btn-primary" data-dismiss="modal" onclick="clickModalModMultisig()">OK</button>
		<button type="button" class="btn btn-default" data-dismiss="modal">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
	</div><!-- /.modal-footer -->
</div></div><!-- /.modal-content --><!-- /.modal-dialog -->
</div><!-- /.modal -->

<!-- é€£ç½²ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div class="modal fade" id="modal_cosign" tabindex="-1" role="dialog">
<div class="modal-dialog" role="document"><div class="modal-content">

	<div class="modal-header">
		<h5 class="modal-title">é€£ç½²å¾…ã¡ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒã‚ã‚Šã¾ã™</h5>
		<button type="button" class="close" data-dismiss="modal" aria-label="é–‰ã˜ã‚‹"><span aria-hidden="true">&times;</span></button>
	</div>
	<div class="modal-body">
		<label id="modal-label-cosign">å†…å®¹ã‚’ç¢ºèªã—ã¦å¿…è¦ãªå ´åˆã®ã¿é€£ç½²ã—ã¦ãã ã•ã„ã€‚</label>
		<dl id="transfer_info"></dl><!-- ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆè¦ç´  -->
	</div>
	<div class="modal-footer">
		<button type="button" class="btn btn-primary" data-dismiss="modal" onclick="clickModalCosign()">é€£ç½²ã™ã‚‹</button>
		<button type="button" class="btn btn-default" data-dismiss="modal">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
	</div><!-- /.modal-footer -->
</div></div><!-- /.modal-content --><!-- /.modal-dialog -->
</div><!-- /.modal -->

<!-- ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div class="modal fade" id="modal_transaction" tabindex="-1" role="dialog">
<div class="modal-dialog" role="document"><div class="modal-content">

	<div class="modal-header">
		<h5 class="modal-title">ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ç½²åãƒ»é€šçŸ¥</h5>
		<button type="button" class="close" data-dismiss="modal" aria-label="é–‰ã˜ã‚‹"><span aria-hidden="true">&times;</span></button>
	</div>
	<div class="modal-body">
		<label id="modal-label-transaction">å†…å®¹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚</label>
		<dl id="transaction_info"></dl><!-- ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆè¦ç´  -->
	</div>
	<div class="modal-footer">
		<button type="button" class="btn btn-primary" data-dismiss="modal" onclick="clickModalTransaction()">å®Ÿè¡Œ</button>
		<button type="button" class="btn btn-default" data-dismiss="modal">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
	</div><!-- /.modal-footer -->
</div></div><!-- /.modal-content --><!-- /.modal-dialog -->
</div><!-- /.modal -->

<!-- Groupè¿½åŠ ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div class="modal fade" id="modal_add_group" tabindex="-1" role="dialog">
<div class="modal-dialog" role="document"><div class="modal-content">

	<div class="modal-header">
		<h5 class="modal-title">ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆ</h5>
		<button type="button" class="close" data-dismiss="modal" aria-label="é–‰ã˜ã‚‹"><span aria-hidden="true">&times;</span></button>
	</div>
	<div class="modal-body">
		<label>ã‚°ãƒ«ãƒ¼ãƒ—å</label>
		<input type="text" id="modal_add_group_field">
	</div>

	<div class="modal-footer">
		<button type="button" class="btn btn-primary" data-dismiss="modal" onclick="clickModalAddGroup()">OK</button>
		<button type="button" class="btn btn-default" data-dismiss="modal">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
	</div><!-- /.modal-footer -->
</div></div><!-- /.modal-content --><!-- /.modal-dialog -->
</div><!-- /.modal -->


<!-- èªè¨¼ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div class="modal fade" id="modal_auth" tabindex="-1" role="dialog">
<div class="modal-dialog" role="document"><div class="modal-content">

	<div class="modal-header">
		<h5 class="modal-title">èªè¨¼</h5>
		<button type="button" class="close" data-dismiss="modal" aria-label="é–‰ã˜ã‚‹"><span aria-hidden="true">&times;</span></button>
	</div>

	<div class="modal-body">
		<div>
			<label>ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰</label>
			<input type="password" id="modal_input_login_password">
		</div>
	</div>

	<div class="modal-footer">
		<button type="button" class="btn btn-primary" onclick="clickModalAuth()">OK</button>
		<button type="button" class="btn btn-default" data-dismiss="modal">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
	</div><!-- /.modal-footer -->
</div></div><!-- /.modal-content --><!-- /.modal-dialog -->
</div><!-- /.modal -->

<!-- ã‚¢ã‚«ã‚¦ãƒ³ãƒˆé¸æŠãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div class="modal fade" id="modal_account" tabindex="-1" role="dialog">
<div class="modal-dialog" role="document"><div class="modal-content">

	<div class="modal-header">
		<h5 class="modal-title">ã‚¢ã‚«ã‚¦ãƒ³ãƒˆä½œæˆ</h5>
		<button type="button" class="close" data-dismiss="modal" aria-label="é–‰ã˜ã‚‹"><span aria-hidden="true">&times;</span></button>
	</div>
	<div class="modal-body">
		<div>

			<label>ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰è¨­å®š<br></label>
			<input type="password" id="modal_input_password">
			<br>
			<label>ç§˜å¯†éµã‚¤ãƒ³ãƒãƒ¼ãƒˆ</label>
			<input type="password" id="modal_input_private_key" maxlength="64">
			<label>(ã‚¢ã‚«ã‚¦ãƒ³ãƒˆæ–°è¦ä½œæˆã¯æœªå…¥åŠ›ã®ã¾ã¾ã€Œä½œæˆã€ã‚¯ãƒªãƒƒã‚¯)</label>
		</div>
	</div>

	<div class="modal-footer">
		<button type="button" class="btn btn-primary" onclick="clickModalAccount()">ä½œæˆ</button>
		<button type="button" class="btn btn-default" data-dismiss="modal">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
	</div><!-- /.modal-footer -->
</div></div><!-- /.modal-content --><!-- /.modal-dialog -->
</div><!-- /.modal -->

<!-- éµè¡¨ç¤ºãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div class="modal fade" id="modal_key" tabindex="-1" role="dialog">
<div class="modal-dialog" role="document"><div class="modal-content">
	<div class="modal-header">
		<h5 class="modal-title">éµæƒ…å ±</h5>
		<button type="button" class="close" data-dismiss="modal" aria-label="é–‰ã˜ã‚‹"><span aria-hidden="true">&times;</span></button>
	</div>
	<div class="modal-body">
	<div>
		<label>å…¬é–‹éµ</label>
		<textarea class="form-control keyarea" id="modal_public_key" rows="2"  >ã“ã“ã«ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›</textarea>
		<label>ç§˜å¯†éµ</label>
		<textarea class="form-control keyarea" id="modal_private_key" rows="2"  >ã“ã“ã«ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›</textarea>
	</div>
	</div>
	<div class="modal-footer">
		<button type="button" class="btn btn-default" data-dismiss="modal">é–‰ã˜ã‚‹</button>
	</div><!-- /.modal-footer -->
</div></div><!-- /.modal-content --><!-- /.modal-dialog -->
</div><!-- /.modal -->


<script type="text/javascript">

//ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
let encryptedSignerJSON;			//æš—å·åŒ–æ¸ˆã¿ç½²åè€…ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ
let signerRawAddress;
let signerPublicAccount;
let networkType;
let nodeUrl;
let nodeSocket;
let currencyMosaicId;
let signedAggregateTx;
let announcedTxHash;
let accountNames;
let transactionList = new Array();
let currentValueMinApproval = 0;
let currentValueMinRemoval = 0;
let cosignatureRequieredTxes;
let accountMosaics;
let accountAddresses;
//QRã‚¹ã‚­ãƒ£ãƒ³ãƒ¢ãƒ¼ãƒ‰
let scanMode="";
let authMode="login";
let maxCosignatureCount = 0;

const jsondata2 = [
	{ id: 'generalgroup', parent: '#', icon: 'jstree-folder', text: 'ä¸€èˆ¬', state: {'opened': true}},
	{ id: 'eventgroup', parent: '#', icon: 'jstree-folder', text: 'ã‚¤ãƒ™ãƒ³ãƒˆ', state: {'opened': true}},
//	{ id: 'tomatinagroup', parent: 'eventgroup', icon: 'jstree-folder', text: 'ğŸ…Symbolãƒˆãƒãƒ†ã‚£ãƒ¼ãƒŠ', state: {'opened': true}},
];

/* ãƒ‡ãƒãƒƒã‚°ç”¨
var jsondata2 = [
	{ id: 'safegroup', parent: '#', icon: 'jstree-folder', text: 'safe list', state: {'opened': true}},
	{ id: 'group1', parent: 'safegroup', icon: 'jstree-folder', text: 'community1', state: {'opened': true}},
	{ id: '9891967FD57D7A2D660163A24617E8A2991CE66F936BEBFB', parent: 'group1', icon: 'jstree-file', text: 'Ivan2', state: {'opened': true}},
	{ id: '982F38FF42FFD1A1ADBE1D19C0E5F85E47CE368FF373BC40', parent: 'group1', icon: 'jstree-file', text: 'Ivan3', state: {'opened': true}},
	{ id: 'group2', parent: 'safe', icon: 'jstree-folder', text: 'community2', state: {'opened': true}},
	{ id: '98D339A1AFD3D08CF71E944A7D1E6100766F0DE76B02316E', parent: 'group2', icon: 'jstree-file', text: 'Carol', state: {'opened': true}},
	{ id: 'eventgroup', parent: '#', icon: 'jstree-folder', text: 'event', state: {'opened': true}},
	{ id: 'ellen', parent: 'eventgroup', icon: 'jstree-file', text: 'Ellen', state: {'opened': true}},
	{ id: 'frank', parent: 'eventgroup', icon: 'jstree-file', text: 'Frank', state: {'opened': true}},

	{ id: 'ivan', parent: 'dave', icon: 'jstree-file', text: 'Ivan', state: {'opened': true}},
];
*/

const sym = require("/node_modules/symbol-sdk");
const qr  = require("/node_modules/symbol-qr-library");
const Buffer = require("/node_modules/buffer").Buffer;

//ãƒ‡ã‚£ãƒ¼ãƒ—ãƒªãƒ³ã‚¯
const params = new URLSearchParams(document.location.search.substring(1));
const reset = params.get("reset");
const network = params.get("network");
const walletId = params.get("id");

let nodeSet;
if(network === "testnet"){
	nodeSet = TEST_NODES;
}else{
	nodeSet = NODES;
}

let storageId = "dodid:";
if(walletId){
	storageId += walletId + ":";
	document.getElementById("wallet_id").textContent = walletId;
}else{
	document.getElementById("wallet_id").textContent = "default";
}


const CONFIG_SYMBOL_APPLICATION = {
	nodes:nodeSet,
	selectNodeCount:3,  //åŒæœŸç¢ºèªã®ãŸã‚ã«æ¥ç¶šã™ã‚‹ãƒãƒ¼ãƒ‰æ•°
	timeout:8000,  //ãƒãƒ¼ãƒ‰æ¥ç¶šå¾…æ©Ÿæ™‚é–“ ãƒŸãƒªç§’
	heightDiffThreshold:  1, // åŒæœŸåˆ¤æ–­ãƒ–ãƒ­ãƒƒã‚¯é«˜å·®
	retryCount:30, //æœ€å¤§å†æ¥ç¶šå›æ•°
	mainnet:"MAIN_NET",
	testnet:"TEST_NET"
};

//ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
startSymbolApplication(

	CONFIG_SYMBOL_APPLICATION,
	//åˆæœŸè¨­å®šå®Œäº†å¾Œ onReady
	async function(node){

		$.toast({heading: 'Information',text: 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šï¼šSymbol',showHideTransition: 'plain',icon: 'info',});

		//ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
		nodeUrl = node.url;
		nodeSocket = node.socket;
		networkType = sym.NetworkType[configSymbolApplication[node.network.identifier]];
		generationHash = node.network.generationHashSeed;
		epochAdjustment = node.network.epochAdjustment.slice(0,-1);
		currencyMosaicId = node.network.currencyMosaicId.split("'").join("").slice(2);

		socketSend(nodeSocket,'block');

		if(localStorage.getItem(storageId) == null|| reset === "true"){
			$("#modal_account").modal("show");
		}else{
			$("#modal_auth").modal("show");
		}
	},
	//onStatusChange ãƒãƒ¼ãƒ‰å†é¸æŠæ™‚
	function(event){

		if(event.name == "retry"){	$.toast({heading: 'Warning',text: 'ãƒãƒ¼ãƒ‰å†æ¥ç¶š',	showHideTransition: 'plain',icon: 'warning'	});
		}else{
			if(event.data){
				$.toast({heading: 'Error',	text: 'Connection Failed',		showHideTransition: 'fade',	icon: 'error'	});
				console.log(event.data);
			}else{
				$.toast({heading: event.name,	text: event.message,		showHideTransition: 'fade',	icon: 'error'	});
			}
		}
	},
	//QRå—ä¿¡æ™‚:onPhysicalMessage
	async function(event){

		console.log(event);

		let rawAddress;
		if(event.data.publicKey){
			rawAddress = sym.PublicAccount.createFromPublicKey(event.data.publicKey,networkType).address.plain();
		}else if(event.data.address){
			rawAddress = event.data.address.address;
		}else{
			alert("å¯¾å¿œã—ã¦ã„ãªã„QRã‚³ãƒ¼ãƒ‰ã§ã™ã€‚");
			return;
		}

		if(scanMode === "add_address"){             scanAddAddress(rawAddress);
		}else if(scanMode === "add_multisig"){await scanAddMultisig(rawAddress);
		}else if(scanMode === "del_multisig"){await scanDelMultisig(rawAddress);
		}

		$('#modal_qr_scan').modal('hide');
	},
	//onSocketMessage ã‚½ã‚±ãƒƒãƒˆå—ä¿¡æ™‚
	async function(event){

		if(event.topic.includes("unconfirmedAdded/")){
			txType = event.data.transaction.type;
			if(txType === 16712){ // ãƒãƒƒã‚·ãƒ¥ãƒ­ãƒƒã‚¯

				$.toast({heading: 'Information',text: 'ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒ­ãƒƒã‚¯æº–å‚™ä¸­',showHideTransition: 'plain',icon: 'info',});
			}

		}else if(event.topic.includes("confirmedAdded/"  )){

			txType = event.data.transaction.type;
			if(txType === 16712){

				nodeFetch(nodeUrl + "/transactions/partial","PUT",{"payload": signedAggregateTx.payload});
				announcedTxHash = signedAggregateTx.hash;
				$.toast({heading: 'Information',text: 'ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³é€šçŸ¥',showHideTransition: 'plain',icon: 'info',});
				console.log(signedAggregateTx);
				clog(nodeUrl,signedAggregateTx);
			}

			if(event.data.meta.hash === announcedTxHash){
				$('#transaction_tree').jstree(true).delete_node($('#transaction_tree').jstree(true));

				$('#transaction_tree').jstree('delete_all');
				$('#transaction_tree').jstree('refresh');
				transactionList = new Array();
				$.toast({heading: 'Success'    ,text: 'ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³æ‰¿èª',showHideTransition: 'plain',icon: 'success'});
				document.querySelectorAll("span.close-jq-toast-single").forEach(
					span=> {
						if(span.parentElement.textContent.includes("é€£ç½²")){
							span.click();
						}
					}
				);
			}

		}else if(event.topic.includes("partialAdded/"	 )){
			const res = await checkPartialTransaction();
			if(res){
				$.toast({heading: 'Information',text: 'é€£ç½²å‡¦ç†ä¸­...',showHideTransition: 'plain',icon: 'info',hideAfter:false});
			}
		}else if(event.topic.includes("status/" 		 )){$.toast({heading: 'Error'	   ,text: event.data.code,				showHideTransition: 'plain',hideAfter: false,icon: 'error'});
		}
	},
	//onSocketResumed ã‚½ã‚±ãƒƒãƒˆå†èµ·å‹•æ™‚
	function(ws){

		nodeSocket = ws;
		socketSend(nodeSocket,'block');
		socketSend(nodeSocket,'status/'   + signerRawAddress);
		socketSend(nodeSocket,'confirmedAdded/'   + signerRawAddress);
		socketSend(nodeSocket,'unconfirmedAdded/' + signerRawAddress);
		$.toast({heading: 'Warning',text: 'Socket Resumed',showHideTransition: 'plain',icon: 'warning'});
	},
	async function(){/* onVisible ç”»é¢ãƒ•ã‚©ãƒ¼ã‚«ã‚¹å›å¾©æ™‚     */}
);

//ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•æ™‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯çµ‚äº†
////////////////////////////////////////////////////////////////////////////////////////////
// ä»¥ä¸‹é–¢æ•°ç¾¤

async function clickModalAccount(){

	const pw = document.getElementById('modal_input_password');
	const pk  = document.getElementById('modal_input_private_key');

	let signerAccount;
	if(pk.value == ''){
		signerAccount = sym.Account.generateNewAccount(networkType);
	}else{
		try{
			signerAccount = sym.Account.createFromPrivateKey(pk.value,networkType);
		}catch(err){
			alert("ç§˜å¯†éµãŒæ­£ã—ãå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
			return;
		}
	}
	$("#modal_account").modal("hide");

	signerPublicAccount = signerAccount.publicAccount;
	const signerQR = qr.QRCodeGenerator.createExportAccount(signerAccount.privateKey, networkType, null,pw.value); //passã«ã¯èªè¨¼ã—ãŸã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‹ã‚‰

	encryptedSignerJSON = signerQR.toJSON();

	if(localStorage.getItem(storageId)){
		if(window.confirm("ä¿å­˜ã—ã¦ã„ã‚‹éµæƒ…å ±ã‚’æ›´æ–°ã—ã¾ã™ã‹ï¼Ÿ")){
			localStorage.setItem(storageId,encryptedSignerJSON);
		}else{
			alert("ã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼ˆæ–°è¦ä½œæˆï¼‰ã—ãŸéµã‚’ä¿å­˜ã›ãšã«ãƒ„ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã‚’é–‰ã˜ã‚‹ã¨æ¶ˆå»ã•ã‚Œã¾ã™ã€‚");
		}
	}else{
		localStorage.setItem(storageId,encryptedSignerJSON);
	}
	delete signerAccount;
	delete signerQR;
	delete pw;
	delete pk;

	await settingSignerAccount(signerPublicAccount);
}

async function clickModalAuth(){

	const pw = document.getElementById('modal_input_login_password');
	let signerQR;
	try{
		signerQR = qr.AccountQR.fromJSON(localStorage.getItem(storageId),pw.value);
	}catch(err){
		alert("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚");
		return;
	}

	$("#modal_auth").modal("hide");
	const signerAccount = sym.Account.createFromPrivateKey(signerQR.accountPrivateKey,networkType);
	signerPublicAccount = signerAccount.publicAccount;

	delete pw;
	delete signerQR;

	if(authMode === "transaction"){

		const aggregateTx = sym.AggregateTransaction.createBonded(
			sym.Deadline.create(epochAdjustment),
			transactionList,
			networkType,
			[],
//			sym.UInt64.fromUint(100000)
		).setMaxFeeForAggregate(100, maxCosignatureCount);

		signedAggregateTx = signerAccount.sign(aggregateTx, generationHash);
		const hashLockTx = sym.HashLockTransaction.create(
			sym.Deadline.create(epochAdjustment),
			new sym.Mosaic(new sym.MosaicId(currencyMosaicId), sym.UInt64.fromUint(10000000)),
			sym.UInt64.fromUint(480), // 120 (1h) x 4
			signedAggregateTx,
			networkType,
		).setMaxFee(100);

		const signedLockTx = signerAccount.sign(hashLockTx, generationHash);
		nodeFetch(nodeUrl + "/transactions","PUT",{"payload": signedLockTx.payload});
		clog(nodeUrl,signedLockTx);

	}else if(authMode === "cosign"){

		//é€£ç½²
		announcedTxHash = cosignatureRequieredTxes[0].meta.hash;
		const cosignedTx = sym.CosignatureTransaction.signTransactionHash(signerAccount,announcedTxHash)
		const payload = {
			parentHash:announcedTxHash,
			signature:cosignedTx.signature,
			signerPublicKey:signerAccount.publicKey,
			version:"0"
		}
		nodeFetch(nodeUrl + "/transactions/cosignature","PUT", payload);

		$("#transfer_info").empty();
		document.querySelectorAll("span.close-jq-toast-single").forEach(
			span=> {
				if(span.parentElement.textContent.includes("ç¢ºèª")){
					span.click();
				}
			}
		);
	}else if(authMode === "key"){
		document.getElementById("modal_public_key").textContent = signerAccount.publicKey;
		document.getElementById("modal_private_key").textContent = signerAccount.privateKey;

		$("#modal_key").modal("show");
	}else{

		await settingSignerAccount(signerPublicAccount);
	}
	delete signerAccount;

}

async function settingSignerAccount(publicAccount){

	const signerAddress       = document.getElementById('signer_address');
	const signerAddressPlain  = document.getElementById('signer_address_plain');

	signerRawAddress = publicAccount.address.plain();
	const addressQR = new qr.AddressQR("",publicAccount.address);
	addressQR.toBase64().subscribe(x => {
		(tag= document.createElement('img')).src = x;
		signerAddress.appendChild(tag);
	});

	signerAddressPlain.textContent = publicAccount.address.plain();

	socketSend(nodeSocket,'status/'   + signerRawAddress);
	socketSend(nodeSocket,'confirmedAdded/'   + signerRawAddress);
	socketSend(nodeSocket,'unconfirmedAdded/' + signerRawAddress);
	socketSend(nodeSocket,'partialAdded/' + signerRawAddress);

	const loadAddressNodes = JSON.parse(localStorage.getItem(storageId + 'address_tree'));
	let addressNodes = jsondata2;
	if(loadAddressNodes){
		addressNodes = jsondata2.concat(loadAddressNodes);
	}
	$('#address_tree'    ).jstree({'core': {'data': addressNodes,"check_callback" : true,"multiple" : false}});
	$('#transaction_tree').jstree({'core': {"check_callback" : true}});

	try{

		const multisigGraph = await getAccountInfoByNodeFetch(signerRawAddress,"/multisig/graph");
		accountNames = await nodeFetchAccountNames(multisigGraph.map(t=>t.multisigEntries).flat().map(fm=>sym.Address.createFromEncoded(fm.multisig.accountAddress).plain()));
		maxCosignatureCount = multisigGraph.map(m=>m.multisigEntries).flat().map(m=>m.multisig.minApproval).reduce((sum, element) => sum + element, 0);

		console.log(multisigGraph);
		$('#multisig_tree').jstree({
			'core': {
				'data': await buildTree(multisigGraph,accountNames)
			}
		})

		accountAddresses = multisigGraph
		.filter(item => item.level < 0) // levelãŒ0æœªæº€ã®è¦ç´ ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
		.map(item => item.multisigEntries).flat()
		.map(x=>sym.Address.createFromEncoded(x.multisig.accountAddress).plain());

		const cannotSignSelf = multisigGraph
			.filter(item => item.level == 0)
			.map(m=>m.multisigEntries).flat()
			.some(s=>s.multisig.cosignatoryAddresses.length > 0);
		if(cannotSignSelf){
			alert("ã“ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¯æ“ä½œã§ãã¾ã›ã‚“");
		}

	}catch(err){

		const address = sym.Address.createFromRawAddress(signerRawAddress);
		accountAddresses = [address.plain()];
		accountNames = await nodeFetchAccountNames(accountAddresses);

		const child = new Object();
		const accountName = accountNames.find(an=>sym.Address.createFromEncoded( an.address).plain() === address.plain());

		if(accountName !== undefined && accountName.names.length > 0){
			child.text = accountName.names[0];
		}else{
			child.text = address.pretty().slice( 0, 20 ) + "..." +  address.pretty().slice( -3 );
		}
		child.id = address.encoded();
		child.parent = "#" ;
		child.state = {'opened':true};
		child.icon = 'jstree-file';

		$('#multisig_tree').jstree({
			'core': {
				'data': [child]
			}
		})
	}

	const unresolvedAddresses = accountNames.map(f=>f.names).flat().map(m=>{
		const encAddress = (networkType + 1).toString(16) 
			+ Buffer.from(new BigInt64Array([BigInt(new sym.NamespaceId(m).id)]).buffer).toString("hex").toUpperCase() 
			+ "000000000000000000000000000000";
		return sym.Address.createFromEncoded(encAddress).plain();
	})

	accountAddresses = accountAddresses.concat(unresolvedAddresses);
	for(targetAddress of accountAddresses){
		socketSend(nodeSocket,'partialAdded/' + targetAddress);
	}

	const res = await checkPartialTransaction();
	if(res){
		$.toast({heading: 'Information',text: 'é€£ç½²å‡¦ç†ä¸­...',showHideTransition: 'plain',icon: 'info',hideAfter:false});
	}
}

///onPhysicalMessage ã“ã“ã‹ã‚‰///
function scanAddAddress(rawAddress){

	const address = sym.Address.createFromRawAddress(rawAddress);
	const addAddress = address.encoded();
	const prettyAddress = address.pretty();
	const nodeText = prettyAddress.slice( 0, 20 ) + "..." +  prettyAddress.slice( -3 );

	if( $('#address_tree').jstree(true).get_node(addAddress)){
		alert("ãã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¯ã™ã§ã«ç™»éŒ²æ¸ˆã¿ã§ã™ã€‚");
		return;
	}

	const node = { id: addAddress, address:addAddress ,icon: 'jstree-file', text: nodeText, state: {'opened': true}};
	const selectedParent = $('#address_tree').jstree('get_selected')[0];

	$('#address_tree').jstree(true).create_node( selectedParent, node);
	localStorage.setItem(storageId + 'address_tree',
		JSON.stringify($('#address_tree').jstree(true).get_json('generalgroup', {flat:true}).filter(j=>j.id !== 'generalgroup'))
	);
}

async function scanAddMultisig(rawAddress){

	//é€£ç½²è€…ã«ã—ãŸã„ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ
	const targetCosginerAddress = sym.Address.createFromRawAddress(rawAddress);
	await addMultisigByUnresolved(targetCosginerAddress);
}


async function scanDelMultisig(rawAddress){

	const targetCosginerAddress = sym.Address.createFromRawAddress(rawAddress);
	await delMultisigByUnresolved(targetCosginerAddress);
}
///onPhysicalMessage ã“ã“ã¾ã§///

//QRã‚³ãƒ¼ãƒ‰ã§ã¯ãªãã¦ãƒãƒ¼ãƒ ã‚¹ãƒšãƒ¼ã‚¹ã§èª­ã¿è¾¼ã¿
async function clickModalQrScan(){

	const namespace = document.getElementById("modal_qr_scan_namespace").value ;
	const namespaceId = new sym.NamespaceId(namespace);

	if(scanMode === "add_address"){

		try{
			const namespaceInfo = await nodeFetchNamespaces(namespaceId.toHex());
			if( $('#address_tree').jstree(true).get_node("ns:" + namespace)){
				alert("ãã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¯ã™ã§ã«ç™»éŒ²æ¸ˆã¿ã§ã™ã€‚");
				return;
			}

		}catch(err){
			alert("æŒ‡å®šã®ãƒãƒ¼ãƒ ã‚¹ãƒšãƒ¼ã‚¹ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚");
			return;
		}

		const node = { id: "ns:" + namespace ,icon: 'jstree-file', text: namespace, state: {'opened': true}};
		const selectedParent = $('#address_tree').jstree('get_selected')[0];
		$('#address_tree').jstree(true).create_node( selectedParent, node);
		localStorage.setItem(storageId + 'address_tree',
			JSON.stringify($('#address_tree').jstree(true).get_json('generalgroup', {flat:true}).filter(j=>j.id !== 'generalgroup'))
		);
	}else if(scanMode === "add_multisig"){ 

		try{
			const namespaceInfo = await nodeFetchNamespaces(namespaceId.toHex());
			if( $('#multisig_tree').jstree(true).get_node("ns:" + namespace)){
				alert("ãã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¯ã™ã§ã«ç™»éŒ²æ¸ˆã¿ã§ã™ã€‚");
				return;
			}

		}catch(err){
			alert("æŒ‡å®šã®ãƒãƒ¼ãƒ ã‚¹ãƒšãƒ¼ã‚¹ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚");
			return;
		}

		//é€£ç½²è€…ã«ã—ãŸã„ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ
		const targetNamespaceId = namespaceId;
		await addMultisigByUnresolved(targetNamespaceId);

	}else if(scanMode === "del_multisig"){ 

		try{
			const namespaceInfo = await nodeFetchNamespaces(namespaceId.toHex());
			if( $('#multisig_tree').jstree(true).get_node("ns:" + namespace)){
				alert("ãã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¯ã™ã§ã«ç™»éŒ²æ¸ˆã¿ã§ã™ã€‚");
				return;
			}

		}catch(err){
			alert("æŒ‡å®šã®ãƒãƒ¼ãƒ ã‚¹ãƒšãƒ¼ã‚¹ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚");
			return;
		}

		const targetNamespaceId = namespaceId;
		await delMultisigByUnresolved(targetNamespaceId);
	}
	$("#modal_qr_scan").modal("hide");
}

async function addMultisigByUnresolved(unresolvedAddress){

	//ãƒãƒ«ãƒã‚·ã‚°ã«ã—ãŸã„ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ
	const selectedPublicAccount = await nodeFetchSelectedPublicAccount();

	let multisig;
	try{
		const info = await getSelectedAccountInfoByNodeFetch("/multisig");
		multisig = info.multisig;
	}catch(err){
	}

	let multisigTx = transactionList.find(tx => tx.signer.publicKey  === selectedPublicAccount.publicKey && tx.type === 16725);
	if(multisigTx !== undefined){
		multisigTx.addressAdditions.push(unresolvedAddress);
		console.log(multisigTx);
		alert("æ—¢å­˜ã®transaction listã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚");

	}else{

		let minApproval = 1;
		let minRemoval = 1;
		if(multisig && multisig.cosignatoryAddresses.length > 0){
			minApproval = 0;
			minRemoval = 0;
		}

		multisigTx = sym.MultisigAccountModificationTransaction.create(
			sym.Deadline.create(epochAdjustment), 
			minApproval, //æ‰¿èªã®ãŸã‚ã«å¿…è¦ãªæœ€å°ç½²åè€…æ•°å¢—åˆ†
			minRemoval, //é™¤åã®ãŸã‚ã«å¿…è¦ãªæœ€å°ç½²åè€…æ•°å¢—åˆ†
			[unresolvedAddress], //è¿½åŠ å¯¾è±¡ã‚¢ãƒ‰ãƒ¬ã‚¹
			[],//é™¤åå¯¾è±¡ã‚¢ãƒ‰ãƒ¬ã‚¹
			networkType
		);

		transactionList = transactionList.concat(multisigTx.toAggregate(selectedPublicAccount));
	}
	refreshTransactionList();
}

async function delMultisigByUnresolved(unresolvedAddress){

	const selectedPublicAccount = await nodeFetchSelectedPublicAccount();

	let multisig;
	try{
		const info = await getSelectedAccountInfoByNodeFetch("/multisig");
		multisig = info.multisig;
	}catch(err){
	}

	let multisigTx = transactionList.find(tx => tx.signer.publicKey  === selectedPublicAccount.publicKey && tx.type === 16725);

	if(multisigTx !== undefined){
		multisigTx.addressDeletions.push(unresolvedAddress);
		console.log(multisigTx);
		alert("æ—¢å­˜ã®transaction listã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚");

	}else{
		if(multisig && multisig.cosignatoryAddresses.length > 0){
			multisigTx = sym.MultisigAccountModificationTransaction.create(
				sym.Deadline.create(epochAdjustment), 
				-1, //æ‰¿èªã®ãŸã‚ã«å¿…è¦ãªæœ€å°ç½²åè€…æ•°å¢—åˆ†
				-1, //é™¤åã®ãŸã‚ã«å¿…è¦ãªæœ€å°ç½²åè€…æ•°å¢—åˆ†
				[], //è¿½åŠ å¯¾è±¡ã‚¢ãƒ‰ãƒ¬ã‚¹
				[unresolvedAddress],//é™¤åå¯¾è±¡ã‚¢ãƒ‰ãƒ¬ã‚¹
				networkType
			);
			
			transactionList = transactionList.concat(multisigTx.toAggregate(selectedPublicAccount));
		}else{
			alert("ãƒãƒ«ãƒã‚·ã‚°é€£ç½²è€…ãŒå­˜åœ¨ã—ã¾ã›ã‚“");
		}
	}
	refreshTransactionList();

}

//// è»¢é€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ ////
async function createTransferForm(){

	const selectedAccountInfo = await nodeFetchSelectedAccountInfo();

	const mosaics  = await getMosaicsInfoByNodeFetch({ "mosaicIds": selectedAccountInfo.account.mosaics.map(m => m.id)});
	const mosaicNames = await nodeFetchMosaicNames(mosaics.map(m => m.mosaic.id));
	accountMosaics = mosaics.map(m=>{
		return {
			name:mosaicNames.find(mn=>mn.mosaicId == m.mosaic.id).names[0],
			id:m.mosaic.id,
			amount:dispAmount(
				selectedAccountInfo.account.mosaics.find(am=>am.id === m.mosaic.id).amount,
				m.mosaic.divisibility
			)
		}
	});
	addMosaicForm();//ä¸€ã¤ç›®ã®ãƒ¢ã‚¶ã‚¤ã‚¯
}

function clickModalAddMosaicForm(){
	addMosaicForm()
}

function addMosaicForm() {

	const formContainer = document.getElementById("form-container");
	const formTemplate  = document.getElementById("form_template");
	const newForm = formTemplate.content.cloneNode(true);

	// å‰Šé™¤ãƒœã‚¿ãƒ³ã«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
	newForm.querySelector(".remove-button").addEventListener("click", function() {
		const formToRemove = this.parentElement;
		formContainer.removeChild(formToRemove);
	});

	const selectElement = newForm.querySelector("select");
	while (selectElement.firstChild) {
		selectElement.removeChild(selectElement.firstChild);
	}

	// é¸æŠè‚¢ã‚’å‹•çš„ã«ç”Ÿæˆã—ã¦ã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹ã«è¿½åŠ ã™ã‚‹
	accountMosaics.forEach((accountMosaic) => {
		const optionElement = document.createElement("option");
		optionElement.value = accountMosaic.id;

		if(accountMosaic.name !== undefined){
			
			optionElement.textContent = accountMosaic.name + "(" + accountMosaic.amount + ")";
		}else{
			optionElement.textContent = accountMosaic.id + "(" + accountMosaic.amount + ")";
		}

		selectElement.appendChild(optionElement);
	});

	formContainer.appendChild(newForm); // æ–°ã—ã„ãƒ•ã‚©ãƒ¼ãƒ ã‚’è¿½åŠ 
}

function clickModalAddGroup(){

	const parent = $('#address_tree').jstree('get_selected')[0];
	const tree = $('#address_tree').jstree(true).get_json('#', {flat:true});
	const addGroupField = document.getElementById("modal_add_group_field").value;
	const parentArray = tree.filter(t=>t.parent === parent);
	const parentCount = parentArray.length + 1;
	const node = { id: parent + "_" + parentCount,  icon: 'jstree-folder', text: addGroupField, state: {'opened': true}};

	$('#address_tree').jstree(true).create_node( parent, node);
	$('#modal_add_group').modal('hide');
	document.getElementById("modal_add_group_field").value = "";

	localStorage.setItem(storageId + 'address_tree',
		JSON.stringify($('#address_tree').jstree(true).get_json('generalgroup', {flat:true}).filter(j=>j.id !== 'generalgroup'))
	);
}

async function checkPartialTransaction(){

	const partialAggTxes = await Promise.all(
		accountAddresses.map(
			address => nodeFetch(nodeUrl + "/transactions/partial?address=" + address)
		)
	);

	const partialHashes = Array.from(new Set(
		partialAggTxes.map(x => JSON.parse(x).data).flat()
		.map(x=>x.meta.hash)
	));

	if(partialHashes.length > 0){
		const partialTxes = await nodeFetch(nodeUrl + "/transactions/partial", 'POST', {"transactionIds": partialHashes});

		//èµ·æ¡ˆè€…ã§ãªãã€ç½²åæ¸ˆã¿ã§ã‚‚ãªã„ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ã¿æŠ½å‡ºã€‚
		const publicKey = signerPublicAccount.publicKey;
		cosignatureRequieredTxes = JSON.parse(partialTxes)
		.filter(x => x.transaction.signerPublicKey !== publicKey)
		.filter(x => !x.transaction.cosignatures.map(c=>c.signerPublicKey).includes(publicKey));

		//ãƒ‘ãƒ¼ã‚·ãƒ£ãƒ«ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®1ã¤ã‚’æŠœç²‹ã§è¡¨ç¤º
		//æ”¹å–„ã®ä½™åœ°ã‚ã‚Š TODO
		const targetRawAddress = JSON.parse(partialTxes)[0].transaction.transactions.map(tf=> sym.Address.createFromPublicKey(tf.transaction.signerPublicKey,networkType).plain())[0];
		const signer = sym.PublicAccount.createFromPublicKey(JSON.parse(partialTxes)[0].transaction.signerPublicKey,networkType).address.encoded();
		const signedCosigners = JSON.parse(partialTxes)[0].transaction.cosignatures.map(c=>sym.PublicAccount.createFromPublicKey(c.signerPublicKey,networkType).address.plain())

		let multisigGraph;
		try{
			multisigGraph = await getAccountInfoByNodeFetch(targetRawAddress,"/multisig/graph");
			console.log(multisigGraph);
			accountNames = await nodeFetchAccountNames(multisigGraph.map(t=>t.multisigEntries).flat().map(fm=>sym.Address.createFromEncoded(fm.multisig.accountAddress).plain()));

			$('#partial_transaction_tree').jstree({
				'core': {
					'data': await buildTree(multisigGraph,accountNames,signer,signedCosigners)
				}
			})
		}catch(err){

			//ãƒãƒ«ãƒã‚·ã‚°ã‚’ã¾ã æ§‹æˆã—ã¦ã„ãªã„ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¯ã“ã¡ã‚‰ã¸é€ƒãŒã™
			//æœªå®Ÿè£… TODO
		}

		if(cosignatureRequieredTxes.length > 0){
			$.toast({
				heading: 'Information',
				text: 'é€£ç½²å¾…ã¡ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ <a href="javascript:void(0)" onclick="showCosignModal()">ç¢ºèª</a>',
				showHideTransition: 'plain',
				icon: 'info',
				hideAfter:false
			});
			console.log(cosignatureRequieredTxes);

			return false;//ã™ã§ã«toastã—ãŸã®ã§falseã§è¿”ã™ã€‚
		}else{

			return true;//å‘¼ã³å‡ºã—å…ƒã«toastã®å¿…è¦æ€§ã‚’trueã§ä¼ãˆã‚‹ã€‚
		}
	}
	return false;
}

async function refreshTransactionList(){

	$('#transaction_tree').jstree(true).refresh();
	for(let tx of transactionList){

		const id = tx.deadline.toString();

		if(tx.type === 16725){

			createFolder("#transaction_tree",id,sym.TransactionType[tx.type],"#");

			const signerAddress = tx.signer.address;
			const accountName = accountNames.find(an=>an.address === signerAddress.encoded());
			let signerAddressText; 
			if(accountName !== undefined && accountName.names.length > 0){
				signerAddressText = accountName.names[0];
			}else{
				signerAddressText = signerAddress.pretty().slice( 0, 20 ) + "..." +  signerAddress.pretty().slice( -3 );
			}

			createFile('#transaction_tree',id + "signer"          ,"å¯¾è±¡è€…ï¼š" + signerAddressText,id);
			createFile('#transaction_tree',id + "minApprovalDelta","minApprovalDeltaï¼š" + tx.minApprovalDelta,id);
			createFile('#transaction_tree',id + "minRemovalDelta" ,"minRemovalDeltaï¼š" + tx.minRemovalDelta,id);
			createFolder("#transaction_tree",id + "addressAdditions","addressAdditions",id);

			for(var address of tx.addressAdditions){

				let nodeText;
				if(address.constructor.name === "NamespaceId"){

					nodeText = address.fullName;

				}else{
					const prettyAddress = address.pretty();
					nodeText = prettyAddress.slice( 0, 20 ) + "..." +  prettyAddress.slice( -3 );
				}
				createFile("#transaction_tree",id + address.plain() + "addressAdditions" ,nodeText,id + "addressAdditions");
			}

			createFolder("#transaction_tree",id + "addressDeletions","addressDeletions",id);
			for(var address of tx.addressDeletions){

				let nodeText;
				if(address.constructor.name === "NamespaceId"){

					nodeText = address.fullName;

				}else{
					const prettyAddress = address.pretty();
					nodeText = prettyAddress.slice( 0, 20 ) + "..." +  prettyAddress.slice( -3 );
				}
				createFile('#transaction_tree',id + address.plain() + "addressDeletions" ,nodeText,id + "addressDeletions");
			}
		}else if(tx.type === 16724){

			let nodeText;
			let suffix;
			if(tx.recipientAddress.constructor.name === "NamespaceId"){

				suffix = tx.recipientAddress.fullName;
				nodeText = suffix;

			}else{
				
				suffix = tx.recipientAddress.pretty();
				nodeText = suffix.slice( 0, 20 ) + "..." +  suffix.slice( -3 );
			}

			createFolder("#transaction_tree",id + suffix,sym.TransactionType[tx.type],"#");

			const signerAddress = tx.signer.address;
			const accountName = accountNames.find(an=>an.address === signerAddress.encoded());
			let signerAddressText;
			if(accountName !== undefined && accountName.names.length > 0){
				signerAddressText = accountName.names[0];
			}else{
				signerAddressText = signerAddress.pretty().slice( 0, 20 ) + "..." +  signerAddress.pretty().slice( -3 );
			}

			createFile('#transaction_tree',id + suffix + "signer"          ,"é€ä¿¡è€…ï¼š" + signerAddressText,id + suffix);
			createFile('#transaction_tree',id + suffix + "recipientAddress","å—ä¿¡è€…ï¼š" + nodeText,id + suffix);
			createFolder("#transaction_tree",id + suffix + "mosaics","mosaics",id + suffix);

			const mosaics = await getMosaicsInfoByNodeFetch({ "mosaicIds": tx.mosaics.map(m=>m.id.toHex())});
			const mosaicNames = await nodeFetchMosaicNames(mosaics.map(m => m.mosaic.id));
			const innerMosaics = tx.mosaics.map(m=>{
				return {
					name:mosaicNames.find(mn=>mn.mosaicId == m.id.toHex()).names[0],
					id:m.id.toHex(),
					amount:dispAmount(
						m.amount.compact(),
						mosaics.find(mf=>mf.mosaic.id === m.id.toHex()).mosaic.divisibility,
					)
				}
			});

			for(var mosaic of innerMosaics){

				let mosaicName;
				if(mosaic.name){
					mosaicName = mosaic.name;
				}else{
					mosaicName = mosaic.id;
				}
				createFile('#transaction_tree',id + suffix + "mosaics"+ mosaic.id,mosaicName + ":" + mosaic.amount,id + suffix + "mosaics");
			}
		}
	}
}

////BUILDING TRANSACTION///////////////////////////////////////////

async function clickModalTransfer() {

	const selectedPublicAccount = await nodeFetchSelectedPublicAccount();

	const formData = [];
	const formElements = document.getElementsByClassName("form_mosaic");
	for (const form of formElements) {
		const mosaicId = form.querySelector("select").value;
		const mosaicInfo = await getMosaicsInfoByNodeFetch({ "mosaicIds": [mosaicId]});
		const amount = Number(form.querySelector("input[type='text']").value) * Math.pow(10,mosaicInfo[0].mosaic.divisibility);
		formData.push({ mosaicId: mosaicId, amount: amount });
	}

	const message = document.getElementById("message").value;
	const mosaicList = formData.map(f=>new sym.Mosaic(new sym.MosaicId(f.mosaicId),sym.UInt64.fromUint(f.amount)));
	const selectedAry = $('#address_tree').jstree(true).get_json($('#address_tree').jstree("get_selected"), {flat:true});
	const selectedTarget = selectedAry.filter(sa => !(sa.id.includes("group") || sa.id === "#")).map(sa=>sa.id);

	const txes = new Array();
	for(encAddress of selectedTarget){

		let recipient;
		if(encAddress.includes("ns:")){
			recipient = new sym.NamespaceId(encAddress.split(":")[1]);
		}else{
			recipient = sym.Address.createFromEncoded(encAddress);
		}
		
		let tx = sym.TransferTransaction.create(
			sym.Deadline.create(epochAdjustment),
			recipient, 
			mosaicList,
			sym.PlainMessage.create(message),
			networkType
		);
		txes.push(tx.toAggregate(selectedPublicAccount));
	}
	console.log(txes);
	transactionList = transactionList.concat(txes);

	refreshTransactionList();
	$('#modal_transfer').modal('hide'); //å¿…è¦
}

async function clickModalModMultisig() {

	const selectedPublicAccount = await nodeFetchSelectedPublicAccount();

	let multisigTx = transactionList.find(tx => tx.signer.publicKey  === selectedPublicAccount.publicKey && tx.type === 16725);
	let chainValueMinApproval = 0;
	let chainValueMinRemoval = 0;
	try{
		const multisig = await getSelectedAccountInfoByNodeFetch("/multisig");
		chainValueMinApproval = multisig.multisig.minApproval;
		chainValueMinRemoval = multisig.multisig.minRemoval;
	}catch(err){}

	if(multisigTx !== undefined){

		multisigTx.minApprovalDelta = currentValueMinApproval - chainValueMinApproval;
		multisigTx.minRemovalDelta = currentValueMinRemoval - chainValueMinRemoval;

		console.log(multisigTx);
		alert("æ—¢å­˜ã®transaction listã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚");

	}else{

		multisigTx = sym.MultisigAccountModificationTransaction.create(
			sym.Deadline.create(epochAdjustment), 
			currentValueMinApproval - chainValueMinApproval, //æ‰¿èªã®ãŸã‚ã«å¿…è¦ãªæœ€å°ç½²åè€…æ•°å¢—åˆ†
			currentValueMinRemoval - chainValueMinRemoval, //é™¤åã®ãŸã‚ã«å¿…è¦ãªæœ€å°ç½²åè€…æ•°å¢—åˆ†
			[], //è¿½åŠ å¯¾è±¡ã‚¢ãƒ‰ãƒ¬ã‚¹
			[],//é™¤åå¯¾è±¡ã‚¢ãƒ‰ãƒ¬ã‚¹
			networkType
		);
		
		transactionList = transactionList.concat(multisigTx.toAggregate(selectedPublicAccount));
	}
	refreshTransactionList();
}

////DISPLAY TRANSACTION///////////////////////////////////////////

async function clickTransaction(){

	let ddTx = "";
	for(const innerTx of transactionList){
		ddTx += await getTxInfo(innerTx);
	}

	$("#transaction_info").append(ddTx);
	$("#modal_transaction").modal("show");
}

async function showCosignModal(){

	let dtTx = "";
	let ddTx = "";
	for(const aggTx of cosignatureRequieredTxes){

		const tx = sym.TransactionMapping.createFromDTO(aggTx);
		const signerAddress = sym.Address.createFromPublicKey(tx.signer.publicKey,networkType);

		dtTx = "<dt>" + sym.TransactionType[tx.type] + "</dt>";
		ddTx = "<dd>èµ·æ¡ˆè€…:" + signerAddress.plain() + "</dd>";

		if(tx.type === 16961){

			for(const innerTx of tx.innerTransactions){
				ddTx += await getTxInfo(innerTx);
			}
		}
	}

	$("#transfer_info").append(dtTx + ddTx);
	$('#modal_cosign').modal('show');
}

async function getTxInfo(innerTx){

	const senderAddress = sym.Address.createFromPublicKey(innerTx.signer.publicKey,networkType);
	const accountName = accountNames.find(an=>an.address === senderAddress.encoded());

	let ddTx;
	switch (sym.TransactionType[innerTx.type]) {
	case "TRANSFER":

		ddTx = "<dt>" + sym.TransactionType[innerTx.type] + "</dt>";

		if(accountName !== undefined && accountName.names.length > 0){
			ddTx += "<dd>é€ä¿¡è€…â†’:" + accountName.names[0]  + "</dd>";

		}else{
			ddTx += "<dd>é€ä¿¡è€…â†’:" + senderAddress.pretty().slice(0,20) + "..." + senderAddress.pretty().slice(-3)  + "</dd>";
		}

		if(innerTx.recipientAddress.constructor.name === "NamespaceId"){
			const namespaceInfo = await nodeFetchNamespaces(innerTx.recipientAddress.toHex());
			const accountNamespace = await nodeFetchAccountNames(sym.Address.createFromEncoded(namespaceInfo.alias.address).plain());

			ddTx += "<dd>â†’å—ä¿¡è€…:" + accountNamespace[0].names[0]  + "</dd>";
		}else{
			const prettyAddress = innerTx.recipientAddress.pretty();
			ddTx += "<dd>â†’å—ä¿¡è€…:" + prettyAddress.slice(0,20) + "..." + prettyAddress.slice(-3)  + "</dd>";
		}

		const mosaics = await getMosaicsInfoByNodeFetch({ "mosaicIds": innerTx.mosaics.map(m=>m.id.toHex())});
		const mosaicNames = await nodeFetchMosaicNames(mosaics.map(m => m.mosaic.id));
		const innerMosaics = innerTx.mosaics.map(m=>{
			return {
				name:mosaicNames.find(mn=>mn.mosaicId == m.id.toHex()).names[0],
				id:m.id,
				amount:dispAmount(
					m.amount,
					mosaics.find(mf=>mf.mosaic.id === m.id.toHex()).mosaic.divisibility,
				)
			}
		});

		for(var mosaic of innerMosaics){

			if(mosaic.name){
				ddTx += "<dd>ã€€[" + mosaic.name + ":" + mosaic.amount + "]</dd>";

			}else{
				ddTx += "<dd>ã€€[" + mosaic.id.toHex() + ":" + mosaic.amount + "]</dd>";
			}
		}
	break;
	case "MULTISIG_ACCOUNT_MODIFICATION":

		ddTx = "<dt>" + sym.TransactionType[innerTx.type] + "</dt>";

		if(accountName !== undefined && accountName.names.length > 0){
			ddTx += "<dd>å¯¾è±¡è€…:" + accountName.names[0]  + "</dd>";

		}else{
			ddTx += "<dd>å¯¾è±¡è€…:" + senderAddress.pretty().slice(0,20) + "..." + senderAddress.pretty().slice(-3)  + "</dd>";
		}

		ddTx += "<dd>minApprovalDelta:" + innerTx.minApprovalDelta  + "</dd>";
		ddTx += "<dd>minRemovalDelta:" + innerTx.minRemovalDelta  + "</dd>";
		ddTx += "<dd>addressAdditions</dd>";
		for(var address of innerTx.addressAdditions){

			let dispAddress;
			if(address.constructor.name === "NamespaceId"){

				//ã‚½ã‚±ãƒƒãƒˆå—ä¿¡ã—ãŸå ´åˆã¯åå‰æƒ…å ±ãŒæŠœã‘è½ã¡ã¦ã„ã‚‹ã®ã§ãƒãƒ¼ãƒ‰ã‹ã‚‰å†å–å¾—
				const namespaceInfo = await nodeFetchNamespaces(address.toHex());
				const accountNamespace = await nodeFetchAccountNames(sym.Address.createFromEncoded(namespaceInfo.alias.address).plain());

				dispAddress = accountNamespace[0].names[0];
			}else{
				dispAddress = address.pretty().slice(0,20) + "..." + address.pretty().slice(-3);
			}

			ddTx += "<dd>ã€€[" + dispAddress + "]</dd>";
		}

		ddTx += "<dd>addressDeletions</dd>";
		for(var address of innerTx.addressDeletions){

			let dispAddress;
			if(address.constructor.name === "NamespaceId"){

				//ã‚½ã‚±ãƒƒãƒˆå—ä¿¡ã—ãŸå ´åˆã¯åå‰æƒ…å ±ãŒæŠœã‘è½ã¡ã¦ã„ã‚‹ã®ã§ãƒãƒ¼ãƒ‰ã‹ã‚‰å†å–å¾—
				const namespaceInfo = await nodeFetchNamespaces(address.toHex());
				const accountNamespace = await nodeFetchAccountNames(sym.Address.createFromEncoded(namespaceInfo.alias.address).plain());

				dispAddress = accountNamespace[0].names[0];
			}else{
				dispAddress = address.pretty().slice(0,20) + "..." + address.pretty().slice(-3);
			}

			ddTx += "<dd>ã€€[" + dispAddress + "]</dd>";
		}

	break;
	default:
		console.log(sym.TransactionType[tx.type]);
		ddTx = "<dt>" + sym.TransactionType[innerTx.type] + "</dt>";
		ddTx += "<dd>ã“ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã¾ã ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“</dd>";
	break;


	}
	return ddTx;

//	var ddTx = "<dd>é€ä¿¡è€…:" + senderAddress.pretty().slice(0,14) + "..." + senderAddress.pretty().slice(-3) + "</dd>";
/*
	switch (sym.TransactionType[tx.type]) {
		case "TRANSFER":
			ddTx += "<dd>â†’å—ä¿¡è€…:" + tx.recipientAddress.pretty().slice(0,14) + "..." + tx.recipientAddress.pretty().slice(-3)  + "</dd>";

			for(var item of tx.mosaics){

				const mosaic = await getMosaicAsset(item.id);
				ddTx += "<dd>ã€€[" + mosaic.label + ":" + dispAmount(item.amount.toString(),mosaic.info.divisibility) + "]</dd>";
			}

			break;
		case "MULTISIG_ACCOUNT_MODIFICATION":	break;
		case "ACCOUNT_METADATA":	break;
		case "NAMESPACE_METADATA":	break;
		case "NAMESPACE_REGISTRATION":	break;
		case "HASH_LOCK":	break;
		case "SECRET_LOCK":	break;
		case "SECRET_PROOF":	break;
		case "MOSAIC_METADATA":	break;
		case "MOSAIC_DEFINITION":	break;
		case "MOSAIC_SUPPLY_CHANGE":	break;
		case "MOSAIC_ALIAS":	break;
		case "ADDRESS_ALIAS":	break;
		case "MOSAIC_GLOBAL_RESTRICTION":	break;
		case "MOSAIC_ADDRESS_RESTRICTION":	break;
		case "ACCOUNT_MOSAIC_RESTRICTION":	break;
		case "ACCOUNT_ADDRESS_RESTRICTION":	break;
		case "ACCOUNT_OPERATION_RESTRICTION":	break;
		case "VOTING_KEY_LINK":	break;
		case "VRF_KEY_LINK":	break;
		case "NODE_KEY_LINK":	break;
		case "ACCOUNT_KEY_LINK":	break;
//		case "AGGREGATE_COMPLETE":	break;
//		case "AGGREGATE_BONDED":	break;

		default:
			console.log(sym.TransactionType[tx.type]);
	}
*/
}

//ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯

function clickModalCosign(){

	authMode = "cosign";
	$('#modal_auth').modal('show');
}

function clickModalTransaction(){

	authMode = "transaction";
	$('#modal_auth').modal('show');
}

function clickKey(){

	authMode = "key";
	$('#modal_auth').modal('show');
}

function clickAddMultisig(){

	if($('#multisig_tree').jstree('get_selected').length == 0){
		alert("ãƒãƒ«ãƒã‚·ã‚°ã‚’å¤‰æ›´ã—ãŸã„ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
		return;
	}

	scanMode = "add_multisig";
	$('#modal_qr_scan').modal('show');
	startVideo("canvas");
}

function clickDelMultisig(){

	if($('#multisig_tree').jstree('get_selected').length == 0){
		alert("ãƒãƒ«ãƒã‚·ã‚°ã‚’å¤‰æ›´ã—ãŸã„ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
		return;
	}

	if($('#multisig_tree').jstree(true).get_json($('#multisig_tree').jstree('get_selected')).icon === "jstree-file"){
		alert("ãƒãƒ«ãƒã‚·ã‚°ä»¥å¤–ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“");
		return;
	}

	scanMode = "del_multisig";
	$('#modal_qr_scan').modal('show');
	startVideo("canvas");
}

function clickAddAddress(){

	if($('#address_tree').jstree('get_selected').length == 0){
		alert("ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¿½åŠ ã—ãŸã„ã‚°ãƒ«ãƒ¼ãƒ—ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
		return
	}

	if($('#address_tree').jstree(true).get_json($('#address_tree').jstree('get_selected')).icon === "jstree-file"){
		alert("ã‚¢ãƒ‰ãƒ¬ã‚¹ã«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“");
		return;
	}

	scanMode = "add_address";
	$('#modal_qr_scan').modal('show');
	startVideo("canvas");
}

function clickAddGroup(){

	if($('#address_tree').jstree('get_selected').length == 0){
		alert("ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¿½åŠ ã™ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
		return;
	}

	if($('#address_tree').jstree(true).get_json($('#address_tree').jstree('get_selected')).icon === "jstree-file"){
		alert("ã‚¢ãƒ‰ãƒ¬ã‚¹ã«ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“");
		return;
	}
	$('#modal_add_group').modal('show');
}

function clickDelGroup(){

	if($('#address_tree').jstree('get_selected').length == 0){
		alert("å‰Šé™¤ã™ã‚‹å¯¾è±¡ãƒãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
		return;
	}

	if(window.confirm("å‰Šé™¤ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ")){
		$('#address_tree').jstree(true).delete_node($('#address_tree').jstree('get_selected')[0]);

		localStorage.setItem(storageId + 'address_tree',
			JSON.stringify($('#address_tree').jstree(true).get_json('generalgroup', {flat:true}).filter(j=>j.id !== 'generalgroup'))
		);
	}
}

async function clickTransfer(){

	$('#modal_transfer').modal('show');
	await createTransferForm();
}

async function clickUpdMultisigMinValue(){

	if($('#multisig_tree').jstree('get_selected').length == 0){
		alert("ãƒãƒ«ãƒã‚·ã‚°ã‚’å¤‰æ›´ã—ãŸã„ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
		return;
	}

	showMultisigMinValue();
	$('#modal_mod_multisig').modal('show');
}

//ãƒ¢ãƒ¼ãƒ€ãƒ«åˆ¶å¾¡

$('#modal_transfer').on('hide.bs.modal', function (e) {

	const formContainer = document.getElementById("form-container");
	formContainer.innerHTML = ''; // ãƒ•ã‚©ãƒ¼ãƒ ã‚³ãƒ³ãƒ†ãƒŠã‚’ç©ºã«ã™ã‚‹
});

$('#modal_qr_scan').on('hide.bs.modal', function (e) {
	stopVideo();		
	clearRect();
	$('#file_image').val("");
});

$('#modal_cosign').on('hide.bs.modal', function (e) {
	$("#transfer_info").empty();
});

$('#modal_transaction').on('hide.bs.modal', function (e) {
	$("#transaction_info").empty();
});

$('#modal_key').on('hide.bs.modal', function (e) {

	document.getElementById("modal_public_key").textContent = "";
	document.getElementById("modal_private_key").textContent = "";
});

$('#modal_auth').on('hide.bs.modal', function (e) {

	document.getElementById('modal_input_login_password').value = "";
});

//mulstisig
const decreaseMinRemoval  = document.getElementById("decreaseMinRemoval");
const increaseMinRemoval  = document.getElementById("increaseMinRemoval");
const decreaseMinApproval = document.getElementById("decreaseMinApproval");
const increaseMinApproval = document.getElementById("increaseMinApproval");
const valueMinRemoval     = document.getElementById("valueMinRemoval");
const valueMinApproval    = document.getElementById("valueMinApproval");

decreaseMinRemoval.addEventListener( "click", function(){currentValueMinRemoval  -= 1;showMultisigMinValue();});
increaseMinRemoval.addEventListener( "click", function(){currentValueMinRemoval  += 1;showMultisigMinValue();});
decreaseMinApproval.addEventListener("click", function(){currentValueMinApproval -= 1;showMultisigMinValue();});
increaseMinApproval.addEventListener("click", function(){currentValueMinApproval += 1;showMultisigMinValue();});

function showMultisigMinValue() {

	valueMinRemoval.textContent = currentValueMinRemoval;
	valueMinApproval.textContent = currentValueMinApproval;
}

async function getSelectedAccountInfoByNodeFetch(infoType){
	const selectedAccount = $('#multisig_tree').jstree('get_selected')[0];
	const res = await getAccountInfoByNodeFetch(sym.Address.createFromEncoded(selectedAccount).plain(),infoType)
	return res;
}

async function nodeFetchSelectedAccountInfo(){
	const selectedAccount = $('#multisig_tree').jstree('get_selected')[0];
	const res = await nodeFetch(nodeUrl + "/accounts/" + sym.Address.createFromEncoded(selectedAccount).plain());
	return JSON.parse(res);
}

async function nodeFetchSelectedPublicAccount(){

	const selectedEncodedAddress = $('#multisig_tree').jstree('get_selected')[0];
	if(selectedEncodedAddress === sym.Address.createFromRawAddress(signerRawAddress).encoded()){
		return signerPublicAccount;
	}else{
		res = await nodeFetch(nodeUrl + "/accounts/" + sym.Address.createFromEncoded(selectedEncodedAddress).plain());
		return sym.PublicAccount.createFromPublicKey(JSON.parse(res).account.publicKey,networkType);
	}
}

async function getAccountInfoByNodeFetch(add,infoType){
	const res = await nodeFetch(nodeUrl + "/account/" + add + infoType);
	return JSON.parse(res);
}

async function getMosaicsInfoByNodeFetch(mosaicIds){
	const res = await nodeFetch(nodeUrl + "/mosaics","POST",mosaicIds)
	return JSON.parse(res);
}

$('#file_image').change(function(e){scanFileImage("file_image");});
</script>
</body>
</html>
